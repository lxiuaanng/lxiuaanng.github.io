[{"content":"\u0026hellip;\u0026hellip;\n[TOC]\n一、 初识 Node.js 1. 浏览器中JavaScript的组成部分 为什么JavaScript可以在浏览器中被执行？\n不同的浏览器使用不同的 JavaScript 解析引擎：\nChrome浏览器=\u0026gt; V8\nFirefox浏览器=\u0026gt;OdinMonkey(奥丁猴)\nSafri 浏览器=\u0026gt;JSCore\nIE 浏览器=\u0026gt;Chakra(查克拉)\netc..\n其中，Chrome浏览器的 V8 解析引擎性能最好！\n2. Node.js简介 2.1 什么是Node.js? Node.js® is a JavaScript runtime built on Chrome\u0026rsquo;s V8 JavaScript engine.\nNode.js 是一个基于 ChromeV8 引擎的 JavaScript 运行环境。\nNode.js 的官网地址：https://nodejs.org/zh-cn/\n2.2 Node.js 中的 JavaScript 运行环境 浏览器 JavaScript 的前端运行环境。\nNode.js 是 JavaScript 的后端运行环境。\nNode.js 中无法调用DOM 和 BOM 等浏览器内置API。\n2.3 Node.js可以做什么 Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js，可以让前端程序员胜任更多的工作和岗位：\n① 基于 Express 框架 (http://www.expressjs.com.cn/），可以快速构建 Web 应用\n② 基于 Electron 框架 (https://electronjs.org/），可以构建跨平台的桌面应用\n③ 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目\n④ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc\u0026hellip;\u0026hellip;\n2.4 Node.js好学吗？怎么学？ 浏览器中的 JavaScript 学习路径：\nJavaScript 基础语法＋浏览器内置API（DOM＋BOM）＋ 第三方库（jQuery、art-template等）\nNode.js 的学习路径：\nJavaScript基础语法 + Node.js 内置 API 模块（fs、path、http等） + 第三方 API 模块（express、mysqI等）\n3. Node.js环境的安装 如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。\n安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页（https://nodejs.org/en/），点击绿色的按钮，下载所需的版本后，双击直接安装即可。\n3.1 区分LTS版本和Current版本的不同 ① LTS 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js。\n② Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的 Bug 或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js。\n3.2 查看已安装的Node.js的版本号 在终端输入命令 node -v 后，按下回车键，即可查看已安装的 Nodejs 的版本打开终端，.\n4. 在Node.js 环境中执行 JavaScript 代码 打开终端，输入node 执行文件的路径\n二、 fs文件系统模块 1. 什么是fs文件系统模块 fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。\n例如:\nfs.readFile() 方法，用来读取指定文件中的内容\nfs.writeFile() 方法，用来向指定的文件中写入内容\n如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：\n1  const fs = require(\u0026#39;fs\u0026#39;)   2. 读取指定文件中的内容 2.1 fs.readFile() 的语法格式 使用 fs.readFile0 方法，可以读取文件中的内容，语法格式如下：\n1  fs.readFile(path[, options], callback)   参数解读:\n参数1：必选参数，字符串，表示文件的路径。\n参数2：可选参数，表示以什么编码格式来读取文件。\n参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。\n2.2 fs.readFile() 的示例代码 以utf8的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //1.导入fs模块，来操作文件 const fs = require(\u0026#39;fs\u0026#39;) //2.调片fs.readFile()方法读取文件 // 参数1：读取文件的存放路径 // 参数2：读取文件时候采用的编码格式，一般默认指定utf8 // 参数3：回调函数，拿到读取失败和成功的结果 err dataStr fs.readFile(\u0026#39;./files/11.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { //2.1 打印失败的结果  console.log(err) console.log(\u0026#39;------\u0026#39;) //2.2 打印成功的结果  console.log(dataStr) })   3. 向指定的文件中写入内容 3.1 fs.writeFile()的语法格式 1  fs.writeFile(file, data[, options], callback)   参数解读：\n参数1：必选参数，需要的字符串，表示文件的存放路径。\n参数2：必选参数，表示要写入的内容。\n参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。\n参数4：必选参数，文件写入完成后的回调函数。\n3.2 fs.writeFile()的示例代码 1 2 3 4 5 6 7 8  //1.导入fs模块，来操作文件 const fs = require(\u0026#39;fs\u0026#39;) //2.调用fs.writeFile()方法，写入文件的内容 fs.writeFile(\u0026#39;./files/2.txt\u0026#39;, \u0026#39;abcd\u0026#39;, function(err){ //2.1 如果文件写入成功，则 err 的值为 null  console.log(err) })   3.3 判断文件是否写入成功 1 2 3 4 5 6 7 8 9 10  //1.导入fs模块，来操作文件 const fs = require(\u0026#39;fs\u0026#39;) //2.调用fs.writeFile()方法，写入文件的内容 fs.writeFile(\u0026#39;./files/2.txt\u0026#39;, \u0026#39;abcd\u0026#39;, function(err){ if (err) { return console.log(\u0026#39;文件写入失败！\u0026#39; + err.message) } console.log(\u0026#39;文件写入成功！\u0026#39;) })   4. 练习 - 考试成绩整理 使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。\n整理前，成绩.txt文件中的数据格式如下：\n小红=99 小白=100 小黄=70 小黑=66 小绿=88 整理完成之后，希望得到的成绩-ok文件中的数据格式如下：\n小红：99 小白：100 小黄：70 小黑：66 小绿：88 核心实现步骤：\n① 导入需要的 fs 文件系统模块\n② 使用 fs.readFile0 方法，读取素材目录下的 成绩.txt 文件\n③ 判断文件是否读取失败\n④ 文件读取成功后，处理成绩数据\n⑤ 将处理完成的成绩数据，调用 fs.writeFile0 方法，写入到新文件 成绩-ok.txt 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  const fs = require(\u0026#39;fs\u0026#39;) fs.readFile(\u0026#39;./成绩.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { if (err) { return console.log(\u0026#39;读取文件失败！\u0026#39; + err.message) } console.log(\u0026#39;读取文件成功！\u0026#39; + dataStr) //先把成绩的数据，按照空格进行分割  const arr1 = dataStr.split(\u0026#39; \u0026#39;) console.log(arr1) //循环分割后和数组，对每一项数据，进行字符串的替换操作  const arr2 = [] arr1.forEach(item =\u0026gt; { arr2.push(item.replace(\u0026#39;=\u0026#39;, \u0026#39;:\u0026#39;)) //push 查找 = 修改为 ：  }) console.log(arr2); //把新数组中的每一项，进行合并，得到一个新的字符串  const newstr = arr2.join(\u0026#39;\\r\\n\u0026#39;) console.log(newstr); //调用fs.writeFile()方法，把处理完毕的成绩，写入到新文件中  fs.writeFile(\u0026#39;./成绩-ok.txt\u0026#39;, newstr, function(err) { if (err) { return console.log(\u0026#39;写入文件失败！\u0026#39; + err.message); } console.log(\u0026#39;成绩写入成功！\u0026#39;); }) })   5. fs 模块 - 路径动态拼接的问题 在使用 fs 模块操作件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。\n原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。\n1 2 3 4 5 6 7 8 9 10 11  //在执行2-9行程序时，如图2.3.1 const fs = require(\u0026#39;fs\u0026#39;) fs.readFile(\u0026#39;./files/1.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { if (err) { return console.log(\u0026#39;读取文件失败！\u0026#39; + err.message); } console.log(\u0026#39;读取文件成功！\u0026#39; + dataStr); }) //但是若修改 node 命令的执行目录，就会读取失败，如图2.3.2   解决办法就是绝对路径，但是绝对路径与相对路径的斜线格式不同，为了能表示真正的“\\”，需要修改为“\\”,如：\n1 2 3  ... fs.readFile(\u0026#39;C:\\\\Users\\\\12748\\\\Desktop\\\\vscode\\\\files\\\\1.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { ...   但是使用绝对路径不仅移植性非常差，且不利于维护，使用__dirname就可以完美解决，如：\n1 2 3 4 5 6 7 8 9  const fs = require(\u0026#39;fs\u0026#39;) //__dirname 表示当前所处目录 fs.readFile(__dirname + \u0026#39;\\\\files\\\\1.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, dataStr) { if (err) { return console.log(\u0026#39;读取文件失败！\u0026#39; + err.message); } console.log(\u0026#39;读取文件成功！\u0026#39; + dataStr); })   三、 path 路径模块 1. 什么是 path 路径模块 path 模块是 Node.js 官方提供的、用来处理路径的模共了一系列的方法和属性，用来满足用户对处理需求。如：\npath.join() 方法，用来将多个路径拼接成一个完整的路径字符串\npath.basename() 方法，用来从路径字符串中，将文件名解析出来\n如果要在 JavaScript 代码中，使 path 模块来处理路径，则需要使用如下方式先导入它：\n1  const path = require(\u0026#39;path\u0026#39;)   2. 路径拼接 2.1 path.join() 语法格式 1  path.join([...paths])   参数解读：\n\u0026hellip;paths \u0026lt;string\u0026gt; 路径片段的序列\n返回值：\u0026lt;string\u0026gt;\n2.2 path.join() 的代码示例 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：\n1 2 3 4 5  const pathStr = path.join(\u0026#39;/a\u0026#39;, \u0026#39;/b/c\u0026#39;, \u0026#39;../\u0026#39;, \u0026#39;./d\u0026#39;, \u0026#39;e) consle.log(pathStr) // 输出 \\a\\b\\d\\e const pathStr2 = path.join(__dirname, \u0026#39;./files/1.txt\u0026#39;) console.log(pathStr2）// 输出 当前文件所处目录\\files\\1.txt   3. 获取路径中的文件名 3.1 pal.basename() 的语法格式 使用 path.basename(）方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：\n1  path.basename(path[, ext])   参数解读：\npath \u0026lt;string\u0026gt; 必选参数，表示一个路径的字符串\next \u0026lt;string\u0026gt; 可选参数，表示文件扩展名\n返回: \u0026lt;string\u0026gt; 表示路径中的最后一部分\n3.2 path.basename() 代码示例 1 2 3 4 5 6 7  const fpath =\u0026#39;/a/b/c/index.htTml\u0026#39; // 文件的存放路径  var fullName = path.basename(fpath) console.log(fullName) // 输出 index.html  var namewithoutExt = path.basename(fpath, \u0026#39;.html\u0026#39;) console.log(namewithoutExt）// 输出 index，删除.html扩展名   4. 获取路径中的文件扩展名 4.1 path.wxtname() 的语法格式 1 2 3 4 5 6  const path = require(\u0026#39;path\u0026#39;) const fpath = \u0026#39;/a/b/c/index.html\u0026#39; // 路径字符串  const fext = path.extname(fpath) console.log(fext) // 输出 .html   5. 综合案例 - 时钟案例 5.1 案例要实现的功能 将素材目录下的 index.html 文件拆分成三个文件，分别是：index.css、index.js、index.html\n5.2 案例实现步骤 ① 创建两个正则表达式，分别用来匹配 \u0026lt;style\u0026gt; 和 \u0026lt;script\u0026gt; 标签\n② 使用 fs 模块，读取需要被处理的 HTML 文件\n③ 自定义 resolveCSS 方法，来写入 index.css 样式文件\n④ 自定义 resolveJS 方法，来写入 index.js 脚本文件\n⑤ 自定义 resolveHTML方法，来写入 index.html 文件\n5.3.1 步骤一：导入需要的模块并创建正则表达式 1 2 3 4 5 6 7 8 9 10  // 1.1 导入 fs 文件系统模块 const fs=require(\u0026#39;fs\u0026#39;) // 1.2 导入path 路径处理模块 const path= require(\u0026#39;path\u0026#39;) // 1.3 匹配 \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 标签的正则 //\t其中 \\s 表示空白字符；\\S 表示非空白字符；* 表示匹配任意次 const regStyle = /\u0026lt;style\u0026gt;[\\s\\S]*\u0026lt;\\/style\u0026gt;/ // 1.4 匹配 \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 标签的正则 const regScript = /\u0026lt;script\u0026gt;[\\s\\S]*\u0026lt;\\script\u0026gt;/   5.3.2 步骤二：导入需要的模块并创建正则表达式 1 2 3 4 5 6 7 8 9  // 2.1 读取需要被处理的 HTML 文件 fs.readFile(path.join(__dirname, \u0026#39;../素材/index.html\u0026#39;), \u0026#39;utf8\u0026#39;, function(err, dataStr) { // 2.2 读取 HTML 文件失败  if (err) return console.log(\u0026#39;读取 HTML 文件失败！\u0026#39; + err.message) resolveCSS(dataStr) resolveJS(dataStr) resolveHTML(dataStr) })   5.3.3 步骤三：自定义 resolveCSS 方法 1 2 3 4 5 6 7 8 9 10 11 12  // 3.1 处理 css 样式 function resolveCSS(htmlStr) { // 3.2 使用正则提取页面中的 \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 标签  const r1 = regStyle.exec(htmlStr) // 3.3 将提取出来的样式字符串，进行字符串的 replace 替换操作  const newCSS = r1[0].replace(\u0026#39;\u0026lt;style\u0026gt;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;\u0026lt;/style\u0026gt;\u0026#39;, \u0026#39;\u0026#39;) // 3.4 将提取出来的 css 样式，写入到 index.css 文件中  fs.writeFile(path.join(__dirname, \u0026#39;./clock/index.css\u0026#39;), newCSS, functon(err) { if (err) return console.log(\u0026#39;写入 CSS 样式失败！\u0026#39; + err.message) console.log(\u0026#39;写入 CSS 样式成功！\u0026#39;) }) }   5.3.4 步骤四：定义 resolveJS 方法 1 2 3 4 5 6 7 8 9 10 11 12  // 4.1 处理 js 脚本 function resolveJS(htmlStr) { // 4.2 使用正则提取页面中的 \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 标签  const r2 = reScript.exec(htmlStr) // 4.3 将提取出来的脚本字符串，做进一步的处理  const newJS = r2[0].replace(\u0026#39;\u0026lt;script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;\u0026lt;/script\u0026gt;\u0026#39;, \u0026#39;\u0026#39;) // 4.4 将提取出来的 js 脚本，写入到 index.js 文件中  fs.writeFile(path.join(__dirname, \u0026#39;./clock/index.js\u0026#39;), newJS, function(err) { if (err) return console.log(\u0026#39;写入 JavaScript 脚本失败！\u0026#39; + err.message) console.log(\u0026#39;写入 JS 脚本成功！\u0026#39;) }) }   5.3.5 步骤五： 自定义 resolveHTML 方法 1 2 3 4 5 6 7 8 9 10 11 12  // 5. 处理 html 文件 function resolveHTML(htmlStr) { // 5.1 使用字符串的 replace 方法，把内嵌的 \u0026lt;style\u0026gt; 和 \u0026lt;/script\u0026gt; 标签，替换成外联的 \u0026lt;link\u0026gt; 和 \u0026lt;script\u0026gt; 标签  const newHTML = htmlStr .replace(regStyle, \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./index.css\u0026#34;/\u0026gt;\u0026#39;) .replace(regScript, \u0026#39;\u0026lt;script src=\u0026#34;./index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39;) // 5.2 将替换完成之后的 html 代码，写入到 index.html 文件中  fs.writeFile(path.join(__dirname, \u0026#39;./clock/index.html\u0026#39;), newHTML, function(err) { if (err) return console.log(\u0026#39;写入 HTML 文件失败！\u0026#39; + err.message) console.log(\u0026#39;写入 HTML 页面成功！\u0026#39;) }) }   5.4 案例中的两个注意点 ① fs.writeFile() 方法只能用来创建文件，不能用来创建路径\n② 重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容\n四、http 模块 1. 什么是 http 模块 在网络节点中，负责消费资源的电脑，叫做客户端；对外提供网络资源的电脑，叫做服务器。\nhttp 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。\n如果要希望使用 http 模块创建 Web 服务器，则需要先导入它：\n1  const http = require(\u0026#39;http\u0026#39;)   2. 进一步理解 http 模块的作用 服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。\n在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的\nhttp 模块,通过几行简单的代码，就能轻松手写一个服务器软件，从而对外提供web 服务。\n3. 服务器相关的概念 3.1 IP 地址 IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把”个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。\nIP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0～255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）\n127.0.0.1 代表本机 IP 地址\n3.2 域名和域名服务器 尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不了另一套一字符型的地址方案，即所谓的域名（Domain Name）地址。\nIP地址和域名是对应的关系，这份对应关系存放在一种叫做域名服务器（DNS，Domain name server）的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。\n127.0.0.1 对应的域名是 localhost\n3.3 端口号 计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。\n同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。\n① 每个端口号不能同时被多个 web 服务占用。\n② 在实际应用中，URL 中的 80 端口可以被省略。\n4 创建最基本的 web 服务器 4.1 创建 web 服务器的基本步骤 ① 导入http模块\n② 创建 web 服务器实例\n③ 为服务器实例绑定request 事件\n④ 启动服务器\n4.2.1 步骤1导入 http模块 如果要希望使用 http 模块创建 Web 服务器，则需要先导入它：\n1  const http = require(\u0026#39;http\u0026#39;)   4.2.2 步骤2创建web 服务器实例 调用 http.createServer() 方法，即可快速创建一个 web 服务器实例：\n1  const server = http.createServer()   4.2.3 步骤3为服务器实例绑定 request 事件 为服务器实例绑定request 事件\n1 2 3 4 5  // 使用服务器实例的] .on(）方法，为服务器绑定一个 request 事件 server.on(\u0026#39;request\u0026#39;, function(req, res) { // 只要有客户端来请求我们自己的服务器，就会触发 request 事件，从而调用这个事件处理函数  console.log(\u0026#39;Someone visit our web server.\u0026#39;) })   4.2.4 启动服务器 调用服务器实例的 .listen0 方法，即可启动当前的web 服务器实例:\n1 2 3 4  // 调用 server.listen(端口号，cb回调）方法,即可启动 web 服务器 server.listen(8050, function() { console.log(\u0026#39;httpp server running at http://127.0.0.1:8050\u0026#39;) })   4.3 req 请求对象 只要服务器接收到了了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。如果想在事件处理函数中，访问客户端相关的数据或属性，可以使用如下的方式：\n1 2 3 4 5 6 7  server.on(\u0026#39;request\u0026#39;, (req) =\u0026gt; { // req 是请求对象，它包含了与客户端相关的数据和属性，例如： // req.url 是客户端请求的 URL 地址 // req.method 是客户端的 method 请求类型 const str = `Your request url is ${req.url},and request method is ${req.method}console.log(str) })   ","description":"","id":0,"section":"posts","tags":["技术","Node.js"],"title":"Node.js","uri":"https://lxiuaanng.github.io/en/posts/node.js/"},{"content":"最基础命令，入门级水平\n命令之间相关性差，慎观，慎观。\n第一章   pwd #显示当前用户所处目录\n  cd #在不同的目录中切换\n  ls #列出该目录下的文件及目录\n -a #包括隐藏文件；-t #依照最后修改时间的顺序列出文件\n-l #列出目录下文件好目录的详细信息\n   cat #查看文件内容\n cat 文件1 文件2 \u0026gt; 文件3 #12合并覆盖3\ncat 文件1 文件2 \u0026raquo; 文件3 #12合并附加3\n   more #分屏显示，空格向下移动，q建退出\n  less #回车向下一行，空格向下一页，b向上一页\n  head #默认只显示前十行\n -n #显示前几行\n   tail #显示末尾几行\n  mkdir #创建目录\n rmdir #删除空目录\n   touch #创建文件\n  cp #复制文件\n -R #递归复制\n   mv #文件或目录的移动和重命名\n  rm #删除\n -f #不提示\n-r递归删除\n   diff #比较文件内容的不同\n  ln #硬链接（两个文件指向同一个存储空间）\n -s #软连接（win中的快捷方式）\n   gzip #压缩\n  gunzip #解压缩\n  tar #打包\n tar -cvf 1.tar 2.txt 3.txt\ntar -xvf 1.tar\ntar -czvf 打包并压缩\n   whereis #可执行文件所在地址\n  grep #查找文件中指定的字符串\n  ps #查看系统进程\n  kill #杀死进程\n  top #实时监控进程状况\n  bg #放入后台\n  jobs #查看后台进程\n  fg #调到前台\n  who #查看当前主机用户终端信息\n  第三章   echo #输出字符\n $hello #定义变量hello\n   ls -l /tmp \u0026gt; dir #重定向\n \u0026lt; 输入重定向\n   | #管道，结合命令\n cat /etc/passwd | grep root\n   sh #执行.sh文件\n 可执行文件(x)可以用 ./执行文件 来执行\n   vim #vim编辑器\n a #插入；esc #命令模式；wq #保存并退出\n   chmod #文件权限修改\n -r #可读；4\n-w #可写；2\n-x #可执行；1\n原始权限：rwxrwxrwx 转换数字：(421)(421)(421) 数字表示法： 777\n   chown #修改文件所属用户\n chown 用户 : 属组 文件\n   第四章   /etc/passwd 文件 #用户账户及其相关信息（密码除外），所有人可读\n 用户名：加密口令：UID：GID：用户的描述信息：主目录：命令解释器\n   /etc/shadow 文件 #存放用户密码，仅root可读\n 用户名：加密后的用户口令\n   /etc/group 文件 #用户的组账户信息，所有人可读\n 组群名称：组群口令（一般为空，用 x 占位）：GID：组群成员列表\n   /etc/gshadow 文件 #存放组群的加密口令、组管理员等信息，仅root可读\n 组群名称：加密后的组群口令（没有就！）：组群管理员：成员列表\n   useradd #新建用户\n -c #用户的注释信息\n-u #指定用户UID\n-d #指定用户主目录\n-g #用户所属主组群名称或GID\n-p psaawd #加密口令\n   passwd #设置口令\n -l 锁定停用账户\n-u 口令解除\n-d 口令为空\n   usermod #修改用户的属性\n -g #变更所属用户组\n-G #变更扩展用户组；usermod -G root user1\n-L / -U #锁定用户 / 解锁用户\n-u #修改UID；usermod -u 8888 user1\n   userdel #删除用户\n -r #除/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow中的信息外顺便删除主目录下的所有信息\n   groupadd #创建组群\n  groupmod #修改组群\n -g #修改组群GID\n-n #修改组名\n   gpasswd #为组群添加用户\n -a #把用户加入组；gpasswd -a user1 group1\n-r #取消组密码\n-d #把用户从组中删除\n-A #指派管理员\n   su #切换用户\n  sudo #给用户提供额外权限\n  whoami #我是谁\n  第五章   fdisk #磁盘分区工具\n fdisk 分区目录 #fdisk /dev/sda 在/dev/sda上分区\n：p #查看分区表\n：n #新建分区\n：d #删除分区表\n：q #不保存退出\n：w #保存修改\n   mount #挂载\n mount 设备 挂载目录\n   unmount #卸载\n ","description":"","id":1,"section":"posts","tags":["Linux","知识"],"title":"Linux基础命令","uri":"https://lxiuaanng.github.io/en/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"content":"总体分为三步，相比较其他主题需要一些繁琐的配置，icarus就简单很多\n  登陆GitHub并点此注册一个新的OAuth应用\n随后记录下Client ID与Client Secre，等下要用\n Client ID\nxxxxxxxxxxxxxxxxxxxx\nClient Secret\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n    进入此网页往下拉，有这样一句命令，在博客根目录执行：\n npm i \u0026ndash;save gitalk #安装gitalk插件\n    打开根目录下的_config.icarus.yml文件，添加配置\n comment：\ntype: gitalk\nowner: lxiuaunng #你的GitHub用户名\nrepo: lxiuaunng.github.io #你的博客地址\nclient_id: 0b26fddaf37d93589745\nclient_secret: 1c15538585140bf3ef0b9f5dd2c01569055cf8ba\nadmin: lxiuaunng #同样是你的GitHub用户名\n   4. 在博客根目录下打开git bush，先hexo clean，再hexo s-g-d 基本上就是这样了 ","description":"","id":2,"section":"posts","tags":["HEXO","gitalk"],"title":"HEXO+icarus主题+gitalk评论插件的配置","uri":"https://lxiuaanng.github.io/en/posts/hexo-icarus%E4%B8%BB%E9%A2%98-gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"content":"相比较上一篇文章，这篇算是有了丢丢进步，好歹会写代码块了，md文件还是要多写写，不然很多格式记不住。这篇文章主要纠正了上一篇的错误，以及写明了配置多仓库的正确步骤，有需要就来看一下吧。（ps：config文件建议直接复制我的，以免出现打错字母的情况，不要看我，我没有我不是）\n删除全局配置 git config --global --unset user.name git config --global --unset user.email 配置此仓库1的用户 cd 仓库地址1 git config user.name \u0026quot;xxx\u0026quot; git config user.email \u0026quot;xxx@xxx.com\u0026quot; 配置此仓库2的用户 cd 仓库地址2 git config user.name \u0026quot;xxx\u0026quot; git config user.email \u0026quot;xxx@xxx.com\u0026quot; \u0026hellip;\u0026hellip;\u0026hellip;\n创建公钥 cd ~/.ssh ssh-keygen -t rsa -C \u0026quot;111@xxx.com\u0026quot; id_rsa_111 ssh-keygen -t rsa -C \u0026quot;222@xxx.com\u0026quot; id_rsa_222 -C 表示提供一个注释，用于识别这个密钥。 可以省略\n“邮件地址@youremail.com”：用于识别这个密钥的注释内容\n引号里的内容为注释的内容，所以双引号里面不一定得填邮箱，可以输入任何内容，只要你自己知道这个密钥对应哪个网站的仓库就行了\n然后将.pub文件内容添加到GitHub或gitee的ssh管理库中\n配置config文件 cd ~/.ssh 新建文件config\n输入\n# gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee # github Host 111.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_111 # github Host 222.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_222 仔细看图\n原因：\n ssh 客户端是通过类似git@github.com:githubUserName/repName.git的地址来识别使用本地的哪个私钥的，地址中的 git@github.com 其实就是git@(config文件中的Host值)。 如果所有账号的 Host 值都为 github.com，那么就只能使用一个私钥。所以要对 Host 进行配置，至少让每个账号使用自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，如上面配置中的111.github.com和222.github.com。 配置了别名之后，新的地址就是git@111.github.com:githubUserName/repName.git（在添加远程仓库时使用）。  这样 ssh 在连接时就可以区别不同的账号了。\nssh -T git@111.github.com ssh -T git@222.github.com //测试ssh连接，返回“Hi xxx ...”则成功 查看远程分支 git remote -v 添加远程仓库 cd 仓库1地址 git remote add origin git@111.github.com:githubUserName/repName.git cd 仓库2地址 git remote add origin git@222.github.com:githubUserName/repName.git 如下图，若是出现这种错误：\n则表示远程 origin 已经存在，只需要将远程配置删除，输入上述命令重新添加即可\ngit remote rm origin git remote add origin...... ","description":"相比较上一篇文章，这篇算是有了丢丢进步，好歹会写代码块了，md文件还是要多写写，不然很多格式记不住。这篇文章主要纠正了上一篇的错误，以及写明了配置多仓库的正确步骤，有需要就来看一下吧。（ps：config文件建议直接复制我的，以免出现打错字母的情况，不要看我，我没有我不是）","id":3,"section":"posts","tags":["win10+多仓库配置"],"title":"win10配置多个github仓库","uri":"https://lxiuaanng.github.io/en/posts/win10%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E4%BB%93%E5%BA%93/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":4,"section":"","tags":null,"title":"About","uri":"https://lxiuaanng.github.io/en/about/"}]